package com.ki;

// 문제 : 아래와 같이 출력되도록 해주세요.
// 조건 : `숨쉬다` 기능을 중복하지 말아주세요.

// class Main {
//   public static void main(String[] args) {
//     사람 a사람 = new 사람();
//     a사람.숨쉬다();
//   }
// }
// class 동물 {
//   void 숨쉬다() {
//     System.out.println("숨쉬다.");
//   }
// }
// class 사람 extends 동물 {

// }

//----------------------------------------------
/* 가정
우리는 게임개발회사에 입사했다.
우리에게는 성격좋은 사수 한명이 있다.
내가 개발할 게임은 오리시뮬레이션 게임이다.
선임이 나의 개발을 도와주진 않지만 조언은 해준다.
*/

/* 요구사항
- D1 요구 : 오리를 생성하고 날게하시오.
*/

//class Main {
//    public static void main(String[] args) {
//        오리 a오리 = new 오리();
//        a오리.날다();
//        // 출력 : 오리가 날개로 날아갑니다.
//    }
//}
//class 오리 {
//    void 날다() {
//        System.out.println("오리가 날개로 날아갑니다.");
//    }
//}

//----------------------------------------------
/* 가정
우리는 게임개발회사에 입사했다.
우리에게는 성격좋은 사수 한명이 있다.
내가 개발할 게임은 오리시뮬레이션 게임이다.
선임이 나의 개발을 도와주진 않지만 조언은 해준다.
*/

/* 요구사항
- D1 요구 : 오리를 생성하고 날게하시오.
- D1 완료 : 클래스와 메서드를 만들어서 처리
- D2 요구 : 게임의 디테일을 살리기 위해서 `청둥오리`와 `흰오리`를 생성하고 날게하시오.
*/

//class Main {
//    public static void main(String[] args) {
//        청둥오리 a청둥오리 = new 청둥오리();
//        a청둥오리.날다();
//        // 출력 : 오리가 날개로 날아갑니다.
//
//        흰오리 a흰오리 = new 흰오리();
//        a흰오리.날다();
//        // 출력 : 오리가 날개로 날아갑니다.
//    }
//}
//
//class 오리 {
//    void 날다() {
//        System.out.println("오리가 날개로 날아갑니다.");
//    }
//}
//class 청둥오리 {
//    void 날다() {
//        System.out.println("오리가 날개로 날아갑니다.");
//}
//
//class 흰오리 {
//    void 날다() {
//        System.out.println("오리가 날개로 날아갑니다.");
//}

//----------------------------------------------
/* 가정
우리는 게임개발회사에 입사했다.
우리에게는 성격좋은 사수 한명이 있다.
내가 개발할 게임은 오리시뮬레이션 게임이다.
선임이 나의 개발을 도와주진 않지만 조언은 해준다.
*/

/* 요구사항
- D1 요구 : 오리를 생성하고 날게하시오.
- D1 완료 : 클래스와 메서드를 만들어서 처리
- D2 요구 : 게임의 디테일을 살리기 위해서 `청둥오리`와 `흰오리`를 생성하고 날게하시오.
- D2 완료 : 클래스와 메서드를 만들어서 처리
- D3 요구 : 오리 계열의 클래스에 날다 메서드가 중복되었습니다. 중복을 제거해주세요.
*/

//class Main {
//    public static void main(String[] args) {
//        청둥오리 a청둥오리 = new 청둥오리();
//        a청둥오리.날다();
//        // 출력 : 오리가 날개로 날아갑니다.
//
//        흰오리 a흰오리 = new 흰오리();
//        a흰오리.날다();
//        // 출력 : 오리가 날개로 날아갑니다.
//    }
//}
//
//class 오리 {
//    void 날다() {
//        System.out.println("오리가 날개로 날아갑니다.");
//    }
//}
//
//class 흰오리 extends 오리 {
//
//}
//
//class 청둥오리 extends 오리 {
//
//}

//---------------------------------------------
/* 가정
우리는 게임개발회사에 입사했다.
우리에게는 성격좋은 사수 한명이 있다.
내가 개발할 게임은 오리시뮬레이션 게임이다.
선임이 나의 개발을 도와주진 않지만 조언은 해준다.
*/

/* 요구사항
- D1 요구 : 오리를 생성하고 날게하시오.
- D1 완료 : 클래스와 메서드를 만들어서 처리
- D2 요구 : 게임의 디테일을 살리기 위해서 `청둥오리`와 `흰오리`를 생성하고 날게하시오.
- D2 완료 : 클래스와 메서드를 만들어서 처리
- D3 요구 : 오리 계열의 클래스에 날다 메서드가 중복되었습니다. 중복을 제거해주세요.
- D3 완료 : 상속을 사용해서 처리
- D4 요구 : 게임의 재미를 위하여 고무오리를 추가하고 날게 하시오.
*/

//class Main {
//    public static void main(String[] args) {
//        청둥오리 a청둥오리 = new 청둥오리();
//        a청둥오리.날다();
//        // 출력 : 오리가 날개로 날아갑니다.
//
//        흰오리 a흰오리 = new 흰오리();
//        a흰오리.날다();
//        // 출력 : 오리가 날개로 날아갑니다.
//
//        고무오리 a고무오리 = new 고무오리();
//        a고무오리.날다();
//        // 출력 : 오리가 날개로 날아갑니다.
//    }
//}
//
//class 오리 {
//    void 날다() {
//        System.out.println("오리가 날개로 날아갑니다.");
//    }
//}
//
//// 오리 => 부모 클래스
//// 흰오리 => 자식 클래스
//// 흰오리 extends 오리 => 흰오리가 오리의 능력을 물려 받는다.
//// "`흰오리`는 `오리`이다." 라고 자바에게 알려준다.
//// `A 는 B 이다.` 테스트에 통과하는 것만 상속이 가능하다.
//// 클래스와 객체는 명사이다.
//// 메서드는 동사이다.
//class 흰오리 extends 오리 {
//
//}
//
//class 청둥오리 extends 오리 {
//}
//
//class 고무오리 extends 오리 {
//
//}

//---------------------------------------------
/* 가정
우리는 게임개발회사에 입사했다.
우리에게는 성격좋은 사수 한명이 있다.
내가 개발할 게임은 오리시뮬레이션 게임이다.
선임이 나의 개발을 도와주진 않지만 조언은 해준다.
*/

/* 요구사항
- D1 요구 : 오리를 생성하고 날게하시오.
- D1 완료 : 클래스와 메서드를 만들어서 처리
- D2 요구 : 게임의 디테일을 살리기 위해서 `청둥오리`와 `흰오리`를 생성하고 날게하시오.
- D2 완료 : 클래스와 메서드를 만들어서 처리
- D3 요구 : 오리 계열의 클래스에 날다 메서드가 중복되었습니다. 중복을 제거해주세요.
- D3 완료 : 상속을 사용해서 처리
- D4 요구 : 게임의 재미를 위하여 고무오리를 추가하고 날게 하시오.
- D4 완료 : 클래스와 메서드를 만들어서 처리
- D5 요구 : 주말 주주회의에서 고무오리가 하늘을 날아다니는 것에 대해서 태클이 들어왔습니다. 고무오리 계열은 하늘을 날 수 없게 해주세요.
*/

// class Main {
//   public static void main(String[] args) {
//     청둥오리 a청둥오리 = new 청둥오리();
//     a청둥오리.날다();
//     // 출력 : 오리가 날개로 날아갑니다.

//     흰오리 a흰오리 = new 흰오리();
//     a흰오리.날다();
//     // 출력 : 오리가 날개로 날아갑니다.

//     고무오리 a고무오리 = new 고무오리();
//     a고무오리.날다();
//     // 출력 : 저는 날 수 없어요. ㅜㅠ
//   }
// }

// class 오리 {
//   void 날다() {
//     System.out.println("오리가 날개로 날아갑니다.");
//   }
// }

// // 오리 => 부모 클래스
// // 흰오리 => 자식 클래스
// // 흰오리 extends 오리 => 흰오리가 오리의 능력을 물려 받는다.
// // "`흰오리`는 `오리`이다." 라고 자바에게 알려준다.
// // `A 는 B 이다.` 테스트에 통과하는 것만 상속이 가능하다.
// // 클래스와 객체는 명사이다.
// // 메서드는 동사이다.
// class 흰오리 extends 오리 {

// }

// class 청둥오리 extends 오리 {
// }

// class 고무오리 {
//   void 날다() {
//     System.out.println("저는 날 수 없어요. ㅜㅠ");
//    //오버라이딩.
//   }
// }

//---------------------------------------------
/* 가정
우리는 게임개발회사에 입사했다.
우리에게는 성격좋은 사수 한명이 있다.
내가 개발할 게임은 오리시뮬레이션 게임이다.
선임이 나의 개발을 도와주진 않지만 조언은 해준다.
*/

/* 요구사항
- D1 요구 : 오리를 생성하고 날게하시오.
- D1 완료 : 클래스와 메서드를 만들어서 처리
- D2 요구 : 게임의 디테일을 살리기 위해서 `청둥오리`와 `흰오리`를 생성하고 날게하시오.
- D2 완료 : 클래스와 메서드를 만들어서 처리
- D3 요구 : 오리 계열의 클래스에 날다 메서드가 중복되었습니다. 중복을 제거해주세요.
- D3 완료 : 상속을 사용해서 처리
- D4 요구 : 게임의 재미를 위하여 고무오리를 추가하고 날게 하시오.
- D4 완료 : 클래스와 메서드를 만들어서 처리
- D5 요구 : 주말 주주회의에서 고무오리가 하늘을 날아다니는 것에 대해서 태클이 들어왔습니다. 고무오리 계열은 하늘을 날 수 없게 해주세요.
- D5 완료 : 메서드 오버라이드를 사용해서 처리
- D6 요구 : 고무오리가 반응이 좋습니다. 고무2오리를 추가하고 날게 해주세요.
*/

// class Main {
//   public static void main(String[] args) {
//     청둥오리 a청둥오리 = new 청둥오리();
//     a청둥오리.날다();
//     // 출력 : 오리가 날개로 날아갑니다.

//     흰오리 a흰오리 = new 흰오리();
//     a흰오리.날다();
//     // 출력 : 오리가 날개로 날아갑니다.

//     고무오리 a고무오리 = new 고무오리();
//     a고무오리.날다();
//     // 출력 : 저는 날 수 없어요. ㅜㅠ

//     고무2오리 a고무2오리 = new 고무2오리();
//     a고무2오리.날다();
//     // 출력 : 저는 날 수 없어요. ㅜㅠ
//   }
// }

// class 오리 {
//   void 날다() {
//     System.out.println("오리가 날개로 날아갑니다.");
//   }
// }

// // 오리 => 부모 클래스
// // 흰오리 => 자식 클래스
// // 흰오리 extends 오리 => 흰오리가 오리의 능력을 물려 받는다.
// // "`흰오리`는 `오리`이다." 라고 자바에게 알려준다.
// // `A 는 B 이다.` 테스트에 통과하는 것만 상속이 가능하다.
// // 클래스와 객체는 명사이다.
// // 메서드는 동사이다.
// class 흰오리 extends 오리 {

// }

// class 청둥오리 extends 오리 {
// }

// class 고무오리 extends 오리 {
//   // 메서드 재정의 라고 합니다.
//   // 메서드 오버라이드 라고도 합니다.
//   // 메서드 재정의 => 부모가 물려준 능력을 다시 구현한다.
//   void 날다() {
//     System.out.println("저는 날 수 없어요. ㅜㅠ");
//   }
// }

// class 고무2오리 extends 오리 {
//   void 날다() {
//     System.out.println("저는 날 수 없어요. ㅜㅠ");
//   }
// }

//---------------------------------------------
/* 가정
우리는 게임개발회사에 입사했다.
우리에게는 성격좋은 사수 한명이 있다.
내가 개발할 게임은 오리시뮬레이션 게임이다.
선임이 나의 개발을 도와주진 않지만 조언은 해준다.
*/

/* 요구사항
- D1 요구 : 오리를 생성하고 날게하시오.
- D1 완료 : 클래스와 메서드를 만들어서 처리
- D2 요구 : 게임의 디테일을 살리기 위해서 `청둥오리`와 `흰오리`를 생성하고 날게하시오.
- D2 완료 : 클래스와 메서드를 만들어서 처리
- D3 요구 : 오리 계열의 클래스에 날다 메서드가 중복되었습니다. 중복을 제거해주세요.
- D3 완료 : 상속을 사용해서 처리
- D4 요구 : 게임의 재미를 위하여 고무오리를 추가하고 날게 하시오.
- D4 완료 : 클래스와 메서드를 만들어서 처리
- D5 요구 : 주말 주주회의에서 고무오리가 하늘을 날아다니는 것에 대해서 태클이 들어왔습니다. 고무오리 계열은 하늘을 날 수 없게 해주세요.
- D5 완료 : 메서드 오버라이드를 사용해서 처리
- D6 요구 : 고무오리가 반응이 좋습니다. 고무2오리를 추가하고 날게 해주세요.
- D6 완료 : 고무2오리를 추가
- D7 요구 : 고무오리계열에서 날다 메서드의 중복을 제거해주세요.
*/

// class Main {
//   public static void main(String[] args) {
//     청둥오리 a청둥오리 = new 청둥오리();
//     a청둥오리.날다();
//     // 출력 : 오리가 날개로 날아갑니다.

//     흰오리 a흰오리 = new 흰오리();
//     a흰오리.날다();
//     // 출력 : 오리가 날개로 날아갑니다.

//     고무오리 a고무오리 = new 고무오리();
//     a고무오리.날다();
//     // 출력 : 저는 날 수 없어요. ㅜㅠ

//     고무2오리 a고무2오리 = new 고무2오리();
//     a고무2오리.날다();
//     // 출력 : 저는 날 수 없어요. ㅜㅠ
//   }
// }

// class 오리 {
//   void 날다() {
//     System.out.println("오리가 날개로 날아갑니다.");
//   }
// }

// // 오리 => 부모 클래스
// // 흰오리 => 자식 클래스
// // 흰오리 extends 오리 => 흰오리가 오리의 능력을 물려 받는다.
// // "`흰오리`는 `오리`이다." 라고 자바에게 알려준다.
// // `A 는 B 이다.` 테스트에 통과하는 것만 상속이 가능하다.
// // 클래스와 객체는 명사이다.
// // 메서드는 동사이다.
// class 흰오리 extends 오리 {

// }

// class 청둥오리 extends 오리 {
// }

// class 고무오리 extends 오리 {
//   // 메서드 재정의 라고 합니다.
//   // 메서드 오버라이드 라고도 합니다.
//   // 메서드 재정의 => 부모가 물려준 능력을 다시 구현한다.
//   void 날다() {
//     System.out.println("저는 날 수 없어요. ㅜㅠ");
//   }
// }

// class 고무2오리 extends 고무오리 {
//   // 메서드 재정의 라고 합니다.
//   // 메서드 오버라이드 라고도 합니다.
//   // 메서드 재정의 => 부모가 물려준 능력을 다시 구현한다.
// }

//----------------------------------------------------------------------------------------------
/* 가정
우리는 게임개발회사에 입사했다.
우리에게는 성격좋은 사수 한명이 있다.
내가 개발할 게임은 오리시뮬레이션 게임이다.
선임이 나의 개발을 도와주진 않지만 조언은 해준다.
*/

/* 요구사항
- D1 요구 : 오리를 생성하고 날게하시오.
- D1 완료 : 클래스와 메서드를 만들어서 처리
- D2 요구 : 게임의 디테일을 살리기 위해서 `청둥오리`와 `흰오리`를 생성하고 날게하시오.
- D2 완료 : 클래스와 메서드를 만들어서 처리
- D3 요구 : 오리 계열의 클래스에 날다 메서드가 중복되었습니다. 중복을 제거해주세요.
- D3 완료 : 상속을 사용해서 처리
- D4 요구 : 게임의 재미를 위하여 고무오리를 추가하고 날게 하시오.
- D4 완료 : 클래스와 메서드를 만들어서 처리
- D5 요구 : 주말 주주회의에서 고무오리가 하늘을 날아다니는 것에 대해서 태클이 들어왔습니다. 고무오리 계열은 하늘을 날 수 없게 해주세요.
- D5 완료 : 메서드 오버라이드를 사용해서 처리
- D6 요구 : 고무오리가 반응이 좋습니다. 고무2오리를 추가하고 날게 해주세요.
- D6 완료 : 고무오리가 반응이 좋습니다. 고무2오리를 추가하고 날게 해주세요.
- D7 요구 : 고무오리계열에서 날다 메서드의 중복을 제거해주세요.
- D7 완료 : 상속으로 해결
- D8 요구 : 자바에서 다중상속은 불가능 합니다. 상속에는 한계가 있습니다. 복잡한 상속을 사용하지 않고 고무오리계열의 중복을 제거해주세요.
  - 복잡한 상속을 사용하지 않는다는 것의 의미 : 모든 오리 계열 클래스들은 부모클래스가 오리 클래서 여야 한다.
*/

//class Main {
//    public static void main(String[] args) {
//        청둥오리 a청둥오리 = new 청둥오리();
//        a청둥오리.날다();
//        // 출력 : 오리가 날개로 날아갑니다.
//
//        흰오리 a흰오리 = new 흰오리();
//        a흰오리.날다();
//        // 출력 : 오리가 날개로 날아갑니다.
//
//        고무오리 a고무오리 = new 고무오리();
//        a고무오리.날다();
//        // 출력 : 저는 날 수 없어요. ㅜㅠ
//
//        고무2오리 a고무2오리 = new 고무2오리();
//        a고무2오리.날다();
//        // 출력 : 저는 날 수 없어요. ㅜㅠ
//    }
//}
//
//class 오리 {
//    void 날다() {
//        System.out.println("오리가 날개로 날아갑니다.");
//    }
//}
//
//// 오리 => 부모 클래스
//// 흰오리 => 자식 클래스
//// 흰오리 extends 오리 => 흰오리가 오리의 능력을 물려 받는다.
//// "`흰오리`는 `오리`이다." 라고 자바에게 알려준다.
//// `A 는 B 이다.` 테스트에 통과하는 것만 상속이 가능하다.
//// 클래스와 객체는 명사이다.
//// 메서드는 동사이다.
//class 흰오리 extends 오리 {
//
//}
//
//class 청둥오리 extends 오리 {
//
//}
//
//class 고무오리 extends 오리 {
//    // 메서드 재정의 라고 합니다.
//    // 메서드 오버라이드 라고도 합니다.
//    // 메서드 재정의 => 부모가 물려준 능력을 다시 구현한다.
//    void 날다() {
//        System.out.println("저는 날 수 없어요. ㅜㅠ");
//    }
//}
//
//class 고무2오리 extends 오리 {
//    void 날다() {
//        System.out.println("저는 날 수 없어요. ㅜㅠ");
//    }
//}

//-----------------------------------------------------------------------------------
// // 문제 : `무기 a무기 = new 칼();` 가 실행되는 세부과정을 자세히 쓰세요.

// class Main {
//   public static void main(String[] args) {
//     // * double d = 5.5; 의 처리과정
//     // 1 : 실수 5.5가 생긴다.
//     // 2 : 오직 실수만 담을 수 있는 변수 d가 생성된다.
//     // 3 : d는 5.5가 자신안에 들어 올 수 있는지 판단한다.(가능)
//     // 4 : d변수에 실수 5.5가 들어간다.
//     double d = 5.5;

//     // * double dd = 5; 의 처리과정
//     // 1 : 정수 5가 생긴다.
//     // 2 : 오직 실수만 담을 수 있는 변수 dd가 생성된다.
//     // 3 : dd는 5가 자신안에 들어 올 수 있는지 판단한다.
//     // 4 : 5는 정수이기 때문에 들어 올 수 없다고 판단한다.(불가능)
//     // 5 : dd가 아쉬워하는 5에게 이렇게 이야기 합니다. `니가 실수로 변환될 수 있다면 들어올 수 있다.`
//     // 6 : 5는 자신의 형태를 버리고 실수화 한다. 즉 5.0으로 변신하다.(캐스팅, 또는 형변환)
//     // 7 : dd로 5.0이 들어간다.
//     double dd = 5;

//     // * int i = 5.5; 의 처리과정
//     // 1 : 실수 5.5가 생긴다.
//     // 2 : 오직 정수만 담을 수 있는 변수 i가 생성된다.
//     // 3 : i는 5.5가 자신에게 담길 수 있는지 체크한다.(불가능)
//     // 4 : i는 아쉬워하는 5.5에게 이렇게 이야기 합니다. `니가 정수가 된다면 들어올 수 있다.`
//     // 5 : 5.5는 도저히 불가능 요구를 받고 치명적인 에러를 발생시킨다.(캐스팅 불가능 으로 인한 에러)
//     // int i = 5.5;

//     무기 a무기 = new 칼();
//   }
// }

// class 무기 {

// }

// class 칼 extends 무기 {

// }

// // 1. 무기 클래스와, 칼 클래스가 있다.
// // 2. "무기" 타입의 변수 a무기를 선언하고, 칼()의 설계도 대로 생성한다.
// // 3. 변수 a무기에 무기 타입의 객체가 생성된다.
// // 4. a무기에는 무기 객체의 리모콘을 가진다.
// // 5. 칼() 객체의 리모콘과 a무기 변수안의 리모콘은 서로 다르다.
// // 6. a무기의 리모콘을 칼 객체의 리모콘으로 변환할 수 있을까 검정한다.
// // 7. 아무런 장치가 없어 변환할 수 없어 에러가 난다.

// //---------------------------------------------------------------

// ---------------------------------------------------------------
// 문제 : 매개변수를 사용해서 전사가 매번 다르게 공격하도록 해주세요.

// class Main {
//   public static void main(String[] args) {
//     전사 a전사 = new 전사();

//     a전사.공격("브라이언", "칼");
//     // 브라이언이(가) 칼(으)로 공격합니다.

//     a전사.공격("필립", "창");
//     // 필립이(가) 창(으)로 공격합니다.

//     a전사.공격("마크", "지팡이");
//     // 마크(가) 지팡이(으)로 공격합니다.
//   }
// }

// class 전사 {
//   void 공격(String user, String weapon) {
//     System.out.println(user + "(가)" + weapon + "(으)로 공격 합니다.");
//   }
// }

//-----------------------------------------------------------------
// 문제 : 매개변수를 사용해서 전사가 매번 다르게 공격하도록 해주세요.

//class Main {
//    public static void main(String[] args) {
//        전사 a전사 = new 전사();
//
//        a전사.공격("브라이언", "칼");
//        // 브라이언이(가) 칼(으)로 공격합니다.
//
//        a전사.재공격();
//        // 브라이언이(가) 칼(으)로 공격합니다.
//
//        a전사.공격("필립", "창");
//        // 필립이(가) 창(으)로 공격합니다.
//
//        a전사.공격("마크", "지팡이");
//        // 마크(가) 지팡이(으)로 공격합니다.
//
//        a전사.재공격();
//        // 마크(가) 지팡이(으)로 공격합니다.
//
//        a전사.재공격();
//        // 마크(가) 지팡이(으)로 공격합니다.
//    }
//}
//
//class 전사 {
//    // 인스턴스 변수 - 함수의 외부, 객체의 내부에 만들어진 변수
//    String lastuser;
//    String lastweapon;
//
//    void 공격(String user, String weapon) {
//        // 지역변수 - 함수 내에서 만들어진 변수
//        System.out.println(user + "(가)" + weapon + "(으)로 공격합니다.");
//        this.lastuser = user;
//        this.lastweapon = weapon;
//    }
//
//    void 재공격() {
//        System.out.println(this.lastuser + "(가)" + this.lastweapon + "(으)로 공격합니다.");
//    }
//}

//-----------------------------------------------------------------------------------------------

// 문제 : `a무기.공격();` 가 실행되는 세부과정을 자세히 쓰세요.

//class Main {
//    public static void main(String[] args) {
//        무기 a무기 = new 칼();
//
//        //
//        a무기.공격();
//    }
//}
//
//class 무기 {
//
//}
//
//class 칼 extends 무기 {
//    void 공격() { }
//}

// 1. 무기 클래스와 칼 클래스를 만들었다.
// 2. 칼 클래스는 부모 클래스의 무기 클래스를 상속 받는다.
// 3. 무기 타입의 a무기 변수를 선언하고, 칼클래스의 설계도로 객체를 생성한다.
// 4. 힙 메모리에 칼 객체가, 스택 메모리에 a무기 변수가 위치하지만, a무기 변수가 갖는 리모콘은
//      무기 클래스에서 받은 리모콘이다.
// 5. 힙 메모리의 칼 객체 리모콘은 어디에도 없고, 수신기만 가지고 있는 셈.
// 6. a무기 변수에서 무기 클래스의 공격 메서드를 실행하려 해도, 무기 클래스 내부에는 아무런 메소드가 없다.

//-----------------------------------------------------------------------------------------
// 문제 : 아래 코드가 실행되도록 해주세요.

//class Main {
//    public static void main(String[] args) {
//        샤오미Tv a샤오미Tv = new 샤오미Tv();
//        삼성Tv a삼성Tv = new 삼성Tv();
//        LGTv aLGTv = new LGTv();
//
//        a샤오미Tv.켜기();
//        // 출력 => 샤오미Tv 켜집니다.
//        a샤오미Tv.끄기();
//        // 출력 => 샤오미Tv 꺼집니다.
//        a샤오미Tv.vr켜기();
//        // 출력 => 샤오미Tv vr켜기!
//
//        a삼성Tv.켜기();
//        // 출력 => 삼성Tv 켜집니다.
//        a삼성Tv.끄기();
//        // 출력 => 삼성Tv 꺼집니다.
//        a삼성Tv.ar켜기();
//        // 출력 => 삼성Tv ar켜기!
//
//        aLGTv.켜기();
//        // 출력 => LGTv 켜집니다.
//        aLGTv.끄기();
//        // 출력 => LGTv 꺼집니다.
//        aLGTv.게임모드전환();
//        // 출력 => LGTv 게임모드전환!
//    }
//}
//class Tv {
//    void 켜기(){
//        System.out.println("켜집니다.");
//    }
//    void 끄기(){
//        System.out.println("꺼집니다.");
//    }
//}
//
//class 샤오미Tv extends Tv {
//    void vr켜기(){
//        System.out.println("샤오미Tv vr켜기!");
//    }
//}
//class 삼성Tv extends Tv{
//    void ar켜기(){
//        System.out.println("삼성Tv ar켜기!");
//    }
//}
//class LGTv extends Tv{
//    void 게임모드전환(){
//        System.out.println("LGTv 게임모드전환!");
//    }
//}

//-----------------------------------------------------------------------------
// 문제 : 정수 i가 가지고 있는 10을 double 형 변수에 넣고 해당 변수의 값을 다시 i에 넣는 코드를 작성해주세요.

//class Main {
//    public static void main(String[] args) {
//        int i = 10;
//        System.out.println(i);
//        double d = i; // 여기선 자동형변환 허용
//        System.out.println(d);
//        i = (int) d; // 여기선 자동형변환 불가능
//        System.out.println(i);
//    }
//}

//----------------------------------------------------------------
// 문제 : 자동차 리모콘이 페라리 객체를 가리키게 한 후
//        해당 리모콘이 가리키고 있는 객체를 다시 페라리 리모콘으로 가리키게(참조하게)
//        하는 코드를 작성해주세요.

//class Main {
//    public static void main(String[] args) {
//        // `a페라리` 변수안의 리모콘은 버튼 개수가 3개 여야 한다.
//        페라리 a페라리 = new 페라리();
//
//        // `a자동차` 변수안의 리모콘은 버튼 개수가 2개 여야 한다.
//        자동차 a자동차;
//
//        // 수동형변환, 수동캐스팅
//        // `a페라리`안에 있던 리모콘은 가지고 있던 버튼 3개 중에서 `뚜껑이_열리다` 버튼이 뽑힌 후 `a자동차`에 저장된다.
//        a자동차 = (자동차)a페라리;
//
//        // 자동형변환, 자동캐스팅
//        // 자바가 판단하기에 안전한 경우만 자동형변환이 가능하다.
//        // 리모콘의 버튼 개수를 줄이는 경우는 언제나 안전하다.
//        a자동차 = a페라리;
//
//        // 아래에서는 `a자동차`변수에 들어있던 리모콘에 `뚜껑이_열리다` 버튼이 추가된다.
//        // 자바에서는 리모콘에 버튼이 빠지는건 상관하지 않지만 추가되는건 굉장히 무서워 한다.
//        // 왜냐하면 추가된 버튼에 해당된 기능이 연결된 객체에 없을 수도 있기 때문이다.
//        // 그렇기 때문에 여기서는 무조건 수동형변환을 사용한다.
//        // 수동형변환을 사용하는 이유는 자바에게 개발자의 의도(이게 실수가 아니라는 뜻)를 명확히 밝히는 것과 같다.
//        페라리 a페라리2 = (페라리)a자동차;
//    }
//}
//class 자동차 {
//    void 달리다() {}
//    void 서다() {}
//}
//class 페라리 extends 자동차 {
//    void 뚜껑이_열리다() {}
//}

//----------------------------------------------------------------

//올바른 리턴타입으로 메서드를 만들어주세요
//public class Main {
//    public static void main(String[] args) {
//        int i = 로봇.get정수();
//        boolean b = 로봇.get논리();
//        사람 a사람 = 로봇.get사람();
//        사람 a사람2 = 로봇.get사람2();
//        사람 a사람3 = 로봇.get사람3();
//        사람 a사람4 = 로봇.get사람4();
//        사람 a사람5 = 로봇.get사람5(123, false);
//        로봇.get사람6(123, false);
//
//    }
//}
//
//class 로봇 extends 사람 {
//    static int get정수() {
//        return 0;
//    }
//
//    static boolean get논리() {
//        return true;
//    }
//
//
//    static 사람 get사람() {
//
//        return null;
//    }
//
//    static 사람 get사람2() {
//        return new 사람();
//    }
//
//    static 사람 get사람3() {
//        사람 a사람 = null;
//        return a사람;
//    }
//
//    static 사람 get사람4() {
//        사람 a사람 = new 사람();
//        return a사람;
//    }
//
//    static 사람 get사람5(int 나이, boolean 기혼여부) {
//        사람 a사람 = new 사람();
//        a사람.나이 = 나이;
//        a사람.기혼여부 = 기혼여부;
//        return a사람;
//    }
//    static void get사람6(int 나이, boolean 기혼여부) {
//    }
//}
//
//class 사람 {
//    int 나이;
//    boolean 기혼여부;
//}

//--------------------------------------------------------------------------------------------\
// 문제 : 아래가 실행되도록 해주세요.

class Main {
    public static void main(String[] args) {
        사람 a사람 = new 사람();
        a사람.나이 = 20;

        a사람.a왼팔 = new 팔();
        a사람.a왼팔.길이 = 100;
    }
}

class 사람 {
    // 클래스안에 변수를 정의 할 수 있다.
    int 나이;
    팔 a왼팔;
}

class 팔 {
    int 길이;
}